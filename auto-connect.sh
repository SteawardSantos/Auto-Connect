#!/bin/bash

# ==========================================
#           VARIABLES DEL SISTEMA
# ==========================================
CONFIG_FILE="/etc/tailscale-bridge.conf"  # Persistencia del NODE_ID
VIRTUAL_IP_BASE="10.200.0"                # Base para IPs virtuales
TARGET_REAL_IP="192.168.41.1"       # IP Real del dispositivo local
WIFI_PASS="SN2008@+"                # ContraseÃ±a del AP
WIFI_IFACE="wlan0"
LAN_IFACE="eth0"
CONN_PROFILE_NAME="WIFI_SECUNDARIA_NAT"
METRIC_VALUE="600"                  # 600 = Prioridad baja (Protege LAN)
MTU_VALUE="1350"                    # MTU conservador para prevenir fragmentaciÃ³n

# ==========================================
#               FUNCIONES
# ==========================================
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

log() { echo -e "${GREEN}[INFO] $1${NC}"; }
warn() { echo -e "${YELLOW}[AVISO] $1${NC}"; }
error() { echo -e "${RED}[ERROR] $1${NC}"; }
debug() { echo -e "${BLUE}[DEBUG] $1${NC}"; }

# ==========================================
#     FUNCIONES DE AUTO-DISCOVERY
# ==========================================

# Auto-detectar o cargar NODE_ID
auto_discover_node_id() {
    local previous_run=false
    
    # 1. Verificar si ya se ejecutÃ³ antes (archivo de configuraciÃ³n existe)
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        if [ -n "$NODE_ID" ] && [ -n "$VIRTUAL_IP" ]; then
            log "âœ… ConfiguraciÃ³n previa detectada (ejecuciÃ³n anterior)" >&2
            debug "NODE_ID guardado: $NODE_ID | IP Virtual: $VIRTUAL_IP" >&2
            previous_run=true
            
            # Verificar si la IP virtual todavÃ­a estÃ¡ en el loopback
            if ip addr show lo | grep -q "$VIRTUAL_IP"; then
                debug "IP virtual $VIRTUAL_IP todavÃ­a activa en loopback" >&2
            else
                warn "IP virtual $VIRTUAL_IP no encontrada (se reconfigurarÃ¡)" >&2
            fi
            
            echo "$NODE_ID"
            return 0
        fi
    fi
    
    # 2. Primera ejecuciÃ³n: Auto-descubrir NODE_ID disponible
    log "Primera ejecuciÃ³n detectada. Buscando NODE_ID disponible..." >&2
    
    # Verificar que Tailscale estÃ© instalado y autenticado
    if ! command -v tailscale &> /dev/null; then
        warn "Tailscale no instalado todavÃ­a. Usando NODE_ID=1 por defecto." >&2
        echo "1"
        return 0
    fi
    
    # Verificar si Tailscale estÃ¡ autenticado
    if ! tailscale status &> /dev/null; then
        warn "Tailscale no autenticado todavÃ­a. Usando NODE_ID=1 por defecto." >&2
        echo "1"
        return 0
    fi
    
    # Escanear red Tailscale para encontrar IPs virtuales existentes
    log "Escaneando red Tailscale para detectar nodos existentes..." >&2
    
    # Obtener todas las rutas anunciadas en la red
    USED_IPS=$(tailscale status --json 2>/dev/null | \
               grep -oP "${VIRTUAL_IP_BASE//./\\.}\.\d+" | \
               sort -u)
    
    # Si no hay resultados, intentar con mÃ©todo alternativo
    if [ -z "$USED_IPS" ]; then
        USED_IPS=$(tailscale status 2>/dev/null | \
                   grep -oP "${VIRTUAL_IP_BASE//./\\.}\.\d+" | \
                   sort -u)
    fi
    
    if [ -n "$USED_IPS" ]; then
        debug "IPs virtuales detectadas en red Tailscale:" >&2
        echo "$USED_IPS" | while read ip; do
            debug "  - $ip" >&2
        done
        
        # Extraer nÃºmeros de nodo usados
        USED_NODES=$(echo "$USED_IPS" | grep -oP "${VIRTUAL_IP_BASE//./\\.}\.(\d+)" | cut -d. -f4 | sort -n)
        
        # Encontrar el primer hueco disponible
        NEXT_ID=1
        for used in $USED_NODES; do
            if [ "$NEXT_ID" -lt "$used" ]; then
                break
            fi
            NEXT_ID=$((used + 1))
        done
        
        log "âœ… NODE_ID asignado automÃ¡ticamente: $NEXT_ID" >&2
        echo "$NEXT_ID"
    else
        # No hay nodos detectados, usar ID 1
        log "No se detectaron nodos existentes. Asignando NODE_ID=1" >&2
        echo "1"
    fi
}

# Guardar configuraciÃ³n para futuras ejecuciones
save_config() {
    local node_id=$1
    local virtual_ip=$2
    
    cat > "$CONFIG_FILE" << EOF
# Auto-generated by auto-connect.sh (v9)
# Generated: $(date)
NODE_ID="$node_id"
VIRTUAL_IP="$virtual_ip"
WIFI_IFACE="$WIFI_IFACE"
LAN_IFACE="$LAN_IFACE"
TARGET_REAL_IP="$TARGET_REAL_IP"
EOF
    
    chmod 600 "$CONFIG_FILE"
    debug "ConfiguraciÃ³n guardada en $CONFIG_FILE" >&2
}

if [ "$EUID" -ne 0 ]; then
  error "Este script requiere sudo."
  exit 1
fi

echo "========================================================"
echo "  Auto-Config RaspberryPi â†’ Tailscale Bridge (v9)"
echo "========================================================"

# Auto-descubrir NODE_ID
NODE_ID=$(auto_discover_node_id)
VIRTUAL_IP="${VIRTUAL_IP_BASE}.${NODE_ID}"

echo "Nodo: $NODE_ID | IP Virtual: $VIRTUAL_IP"
echo ""

# ==========================================
#       PRE-FLIGHT CHECKS (NUEVO)
# ==========================================
log "Ejecutando validaciones de red..."

# ------------------------------------------
# 1A. VERIFICAR ESTADO IPv4 EN LAN (eth0)
# ------------------------------------------
debug "Verificando conectividad IPv4 en $LAN_IFACE..."

# Obtener IP actual de eth0 (IPv4)
ETH0_IPV4=$(ip -4 addr show "$LAN_IFACE" | grep -oP '(?<=inet\s)\d+(\.\d+){3}')

if [ -z "$ETH0_IPV4" ]; then
    warn "âš ï¸  $LAN_IFACE no tiene direcciÃ³n IPv4 asignada."
    
    # Verificar si tiene IPv6 (indicador de DHCP parcial fallido)
    ETH0_IPV6=$(ip -6 addr show "$LAN_IFACE" | grep -oP '(?<=inet6\s)([0-9a-f:]+)(?=/\d+\s+scope\s+global)')
    
    if [ -n "$ETH0_IPV6" ]; then
        error "Detectado problema conocido: IPv6 funcional pero IPv4 fallido en $LAN_IFACE"
        echo ""
        echo "DiagnÃ³stico automÃ¡tico:"
        echo "  - IPv6: âœ… $ETH0_IPV6"
        echo "  - IPv4: âŒ No asignada"
        echo ""
        
        # Verificar logs de DHCP
        DHCP_ERRORS=$(journalctl -u NetworkManager --since "10 minutes ago" 2>/dev/null | grep -i "dhcp\|timeout\|canceled" | tail -5)
        
        if [ -n "$DHCP_ERRORS" ]; then
            warn "Errores DHCP detectados en los Ãºltimos 10 minutos:"
            echo "$DHCP_ERRORS"
            echo ""
        fi
        
        # Intentar descubrir red con ARP (como en el RCA)
        warn "Intentando descubrir red local con ARP sniffing (5 segundos)..."
        timeout 5 tcpdump -i "$LAN_IFACE" -n arp 2>/dev/null | tee /tmp/arp_scan.log &
        TCPDUMP_PID=$!
        sleep 6
        
        # Analizar resultados
        DISCOVERED_NETWORK=$(grep -oP 'tell \K\d+\.\d+\.\d+\.\d+' /tmp/arp_scan.log | head -1)
        
        if [ -n "$DISCOVERED_NETWORK" ]; then
            warn "Red detectada vÃ­a ARP: $DISCOVERED_NETWORK"
            # Extraer los primeros 3 octetos para sugerir subnet
            SUBNET_BASE=$(echo "$DISCOVERED_NETWORK" | cut -d. -f1-3)
            warn "Subnet probable: ${SUBNET_BASE}.0/24"
            echo ""
            echo "SOLUCIÃ“N RECOMENDADA:"
            echo "  1. Configurar IP estÃ¡tica en esta subnet:"
            echo "     sudo nmcli connection modify \"Wired connection 1\" \\"
            echo "       ipv4.method manual \\"
            echo "       ipv4.addresses ${SUBNET_BASE}.222/24 \\"
            echo "       ipv4.gateway ${SUBNET_BASE}.1 \\"
            echo "       ipv4.dns \"8.8.8.8,1.1.1.1\""
            echo ""
            echo "  2. Reiniciar conexiÃ³n:"
            echo "     sudo nmcli connection down \"Wired connection 1\" && \\"
            echo "     sudo nmcli connection up \"Wired connection 1\""
            echo ""
            error "Abortando script. Configura IPv4 manualmente primero."
            exit 1
        else
            error "No se pudo detectar red activa. Verifica el cable Ethernet."
            echo ""
            echo "Comandos de diagnÃ³stico manual:"
            echo "  - Ver configuraciÃ³n: ip addr show $LAN_IFACE"
            echo "  - Ver logs DHCP: journalctl -u NetworkManager -n 50"
            echo "  - Sniffing ARP: sudo tcpdump -i $LAN_IFACE -n arp"
            exit 1
        fi
    else
        error "$LAN_IFACE no tiene IPv4 ni IPv6. Verifica conexiÃ³n fÃ­sica."
        exit 1
    fi
else
    log "âœ… IPv4 detectada en $LAN_IFACE: $ETH0_IPV4"
fi

# ------------------------------------------
# 1B. DETECTAR CONFIGURACIÃ“N MANUAL (NUEVO)
# ------------------------------------------
LAN_CONNECTION=$(nmcli -t -f NAME,DEVICE connection show --active | grep "$LAN_IFACE" | cut -d: -f1)

if [ -n "$LAN_CONNECTION" ]; then
    IPV4_METHOD=$(nmcli -t -f ipv4.method connection show "$LAN_CONNECTION" | cut -d: -f2)
    
    if [ "$IPV4_METHOD" == "manual" ]; then
        log "âœ… ConfiguraciÃ³n manual detectada en $LAN_IFACE (se respetarÃ¡)"
        debug "ConexiÃ³n: $LAN_CONNECTION | MÃ©todo: $IPV4_METHOD"
        MANUAL_CONFIG=true
    else
        log "MÃ©todo IPv4 en $LAN_IFACE: $IPV4_METHOD"
        MANUAL_CONFIG=false
    fi
fi

# ------------------------------------------
# 1C. AJUSTE DE MTU (PREVENCIÃ“N FRAGMENTACIÃ“N)
# ------------------------------------------
CURRENT_MTU=$(cat /sys/class/net/$LAN_IFACE/mtu)

if [ "$CURRENT_MTU" -ne "$MTU_VALUE" ]; then
    log "Ajustando MTU de $LAN_IFACE: $CURRENT_MTU â†’ $MTU_VALUE (previene fragmentaciÃ³n)"
    
    # Hacer persistente en NetworkManager (esto evita "Device or resource busy")
    if [ -n "$LAN_CONNECTION" ]; then
        nmcli connection modify "$LAN_CONNECTION" 802-3-ethernet.mtu "$MTU_VALUE" 2>/dev/null
        # Aplicar reiniciando la conexiÃ³n brevemente
        nmcli connection down "$LAN_CONNECTION" &>/dev/null
        nmcli connection up "$LAN_CONNECTION" &>/dev/null
        log "âœ… MTU actualizado y aplicado vÃ­a NetworkManager"
    else
        # Fallback: cambiar directamente (puede fallar si estÃ¡ en uso)
        ip link set dev "$LAN_IFACE" mtu "$MTU_VALUE" 2>/dev/null && \
            log "âœ… MTU actualizado directamente" || \
            warn "No se pudo cambiar MTU (interfaz en uso). Aplicar manualmente si es necesario."
    fi
else
    log "âœ… MTU de $LAN_IFACE ya configurado: $MTU_VALUE"
fi

# ------------------------------------------
# 2. GESTIÃ“N INTELIGENTE DEL WI-FI
# ------------------------------------------
log "Verificando conectividad Wi-Fi..."

# Encender radio si estÃ¡ apagado
if [ "$(nmcli radio wifi)" != "enabled" ]; then
    warn "Radio Wi-Fi apagado. Encendiendo..."
    nmcli radio wifi on
    sleep 4
fi

# Verificar si ya estamos conectados al perfil correcto
CURRENT_CON=$(nmcli -t -f NAME connection show --active | grep "$CONN_PROFILE_NAME")

if [ "$CURRENT_CON" == "$CONN_PROFILE_NAME" ]; then
    log "âœ… ConexiÃ³n Wi-Fi correcta detectada. Asegurando mÃ©trica..."
    nmcli connection modify "$CONN_PROFILE_NAME" ipv4.route-metric "$METRIC_VALUE"
else
    log "Buscando red APxxxx..."
    # Busca la primera red que cumpla el patrÃ³n
    TARGET_SSID=$(nmcli -t -f SSID device wifi list | grep "^AP[0-9]" | head -n 1)
    
    if [ -z "$TARGET_SSID" ]; then
        error "No se encontraron redes compatibles con patrÃ³n AP[0-9]."
        exit 1
    fi

    log "Red encontrada: $TARGET_SSID. Configurando..."
    
    # Limpieza preventiva
    if nmcli connection show "$CONN_PROFILE_NAME" &> /dev/null; then
        nmcli connection delete "$CONN_PROFILE_NAME" &> /dev/null
    fi

    # Crear conexiÃ³n segura con mÃ©trica baja (no interferir con LAN)
    nmcli connection add type wifi ifname "$WIFI_IFACE" con-name "$CONN_PROFILE_NAME" ssid "$TARGET_SSID" \
        wifi-sec.key-mgmt wpa-psk wifi-sec.psk "$WIFI_PASS" \
        ipv4.route-metric "$METRIC_VALUE" \
        ipv6.method "ignore" > /dev/null
        
    nmcli connection up "$CONN_PROFILE_NAME"
    
    if [ $? -eq 0 ]; then
        log "âœ… Conectado a $TARGET_SSID"
    else
        warn "No se pudo conectar a $TARGET_SSID (no es crÃ­tico si LAN funciona)"
    fi
fi

# ------------------------------------------
# 3. OPTIMIZACIÃ“N Y KERNEL (Idempotente)
# ------------------------------------------
log "Aplicando parches de kernel..."

# OptimizaciÃ³n Ethtool (GRO para bridge)
if command -v ethtool &> /dev/null; then
    ethtool -K "$LAN_IFACE" rx-udp-gro-forwarding on rx-gro-list off &> /dev/null || true
fi

# IP Forwarding (Sobrescritura limpia)
echo "net.ipv4.ip_forward = 1" > /etc/sysctl.d/99-tailscale-nat.conf
echo "net.ipv6.conf.all.forwarding = 1" >> /etc/sysctl.d/99-tailscale-nat.conf

# Optimizaciones adicionales para Raspberry Pi como bridge
echo "net.ipv4.conf.all.rp_filter = 0" >> /etc/sysctl.d/99-tailscale-nat.conf
echo "net.ipv4.conf.$LAN_IFACE.rp_filter = 0" >> /etc/sysctl.d/99-tailscale-nat.conf
echo "net.ipv4.conf.all.accept_source_route = 1" >> /etc/sysctl.d/99-tailscale-nat.conf

sysctl -p /etc/sysctl.d/99-tailscale-nat.conf &> /dev/null

# ------------------------------------------
# 4. IP VIRTUAL (Loopback)
# ------------------------------------------
if ip addr show lo | grep -q "$VIRTUAL_IP"; then
    log "âœ… IP Virtual ya configurada."
else
    log "Asignando IP Virtual $VIRTUAL_IP al loopback..."
    ip addr add "$VIRTUAL_IP/32" dev lo
fi

# ------------------------------------------
# 5. FIREWALL & DNS CHECK
# ------------------------------------------
log "Configurando reglas NAT..."

# Limpieza de reglas NAT previas
iptables -t nat -F

# Reglas de redirecciÃ³n (DNAT Virtual â†’ Real)
iptables -t nat -A PREROUTING -d "$VIRTUAL_IP" -j DNAT --to-destination "$TARGET_REAL_IP"
iptables -t nat -A POSTROUTING -d "$TARGET_REAL_IP" -j MASQUERADE

# Regla adicional: MASQUERADE para trÃ¡fico saliente de la subnet local
iptables -t nat -A POSTROUTING -o tailscale0 -j MASQUERADE

# Persistencia de reglas
if ! dpkg -s iptables-persistent &> /dev/null; then
    log "Instalando 'iptables-persistent'..."
    
    # TRUCO: Si el DNS estÃ¡ roto por Tailscale, intentamos arreglarlo temporalmente
    if ! ping -c 1 -W 2 8.8.8.8 &> /dev/null; then
        warn "Conectividad limitada. Usando DNS pÃºblico temporal..."
        echo "nameserver 8.8.8.8" > /etc/resolv.conf
        echo "nameserver 1.1.1.1" >> /etc/resolv.conf
    fi
    
    DEBIAN_FRONTEND=noninteractive apt-get update && \
    DEBIAN_FRONTEND=noninteractive apt-get install -y iptables-persistent > /dev/null
fi
netfilter-persistent save &> /dev/null

# ------------------------------------------
# 6. TAILSCALE (CON FIX DE DNS)
# ------------------------------------------
log "Aplicando configuraciÃ³n final de Tailscale..."

# Verificar que tailscale estÃ© instalado
if ! command -v tailscale &> /dev/null; then
    error "Tailscale no estÃ¡ instalado. InstÃ¡lalo primero:"
    echo "  curl -fsSL https://tailscale.com/install.sh | sh"
    exit 1
fi

# --accept-dns=false: Evita que Tailscale rompa DNS local/internet
tailscale up \
    --advertise-routes="${VIRTUAL_IP}/32" \
    --accept-routes \
    --accept-dns=false \
    --reset

# Guardar configuraciÃ³n para futuras ejecuciones
save_config "$NODE_ID" "$VIRTUAL_IP"

echo ""
echo "========================================================"
log "âœ… INSTALACIÃ“N COMPLETADA CORRECTAMENTE"
echo "========================================================"
echo " ï¿½ Nodo ID:          $NODE_ID"
echo " ðŸ”— IP Virtual:       $VIRTUAL_IP (vÃ­a Tailscale)"
echo " ðŸŽ¯ Destino Real:     $TARGET_REAL_IP"
echo " ðŸ“¡ Interfaz LAN:     $LAN_IFACE ($ETH0_IPV4)"
echo " ðŸ›¡ï¸  MTU:             $MTU_VALUE (anti-fragmentaciÃ³n)"
echo " ðŸŒ DNS Fix:          ACTIVADO (--accept-dns=false)"
echo " âš™ï¸  Config Manual:    $([ "$MANUAL_CONFIG" == "true" ] && echo "SÃ (respetada)" || echo "NO")"
echo " ðŸ’¾ Config guardada:  $CONFIG_FILE"
echo "========================================================"
echo ""
log "El nodo estÃ¡ listo para funcionar como bridge Tailscale."
log "Para verificar rutas anunciadas: tailscale status"
echo ""
debug "PrÃ³ximas ejecuciones detectarÃ¡n NODE_ID=$NODE_ID automÃ¡ticamente" >&2